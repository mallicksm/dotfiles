{
   "item header": {
      "prefix": ["header"],
      "body": [
         "//=============================================================================",
         "// C Programming",
         "// Created: $CURRENT_MONTH_NAME_SHORT-$CURRENT_DATE-$CURRENT_YEAR",
         "// Author: ${VIM:\\$USER}",
         "//",
         "// Note:",
         "//",
         "// Description: ${1:Description}",
         "//",
         "//============================================================================="
      ],
      "description": "insert header code"
   },
   "item main": {
      "prefix": ["main", "function"],
      "body": [
         "int main(int argc, const char** argv) {",
         "   $0",
         "   return 0;",
         "}"
      ],
      "description": "Code snippet for main function"
   },
   "item for loop": {
      "prefix": ["for"],
      "body": [
         "for (int ${i} = ${1:0}; ${i} < ${2:length}; ${i}++) {",
         "   $0",
         "}"
      ],
      "description": "Code snippet for loop"
   },
   "item while loop": {
      "prefix": ["while"],
      "body": [
         "while ($1) {",
         "   $0",
         "}"
      ],
      "description": ""
   },
   "item do": {
      "prefix": ["do"],
      "body": [
         "do {",
         "   $0",
         "} while($2);"
      ],
      "description": "Code snippet for do...while loop"
   },
   "item if": {
      "prefix": ["if"],
      "body": [
         "if ($1) {",
          "   $0",
         "}"
      ],
      "description": "Code snippet for if statement"
   },
   "else": {
      "prefix": ["else"],
      "body": [
         "else {",
         "   $1",
         "}"
      ],
      "description": "Code snippet for else statement"
   },
   "item else-if": {
      "prefix": ["elseif", "elif", "elsif"],
      "body": [
         "else if ($1) {",
         "   $2",
         "}"
      ],
      "description": "Code snippet for else-if statement"
   },
   "item enum": {
      "prefix": ["enum"],
      "body": [
         "enum ${MyEnum} {",
         "   $1",
         "};"
      ],
      "description": "Code snippet for enum"
   },
   "item #ifdef": {
      "prefix": ["ifdef"],
      "body": [
         "#ifdef ${1:DEBUG}",
         "$0",
         "#endif // ${1}"
      ],
      "description": "Code snippet for #ifdef"
   },
   "item #ifndef": {
      "prefix": ["ifndef"],
      "body": [
         "#ifndef ${1:1}",
         "$0",
         "#endif // ${1}"
      ],
      "description": "Code snippet for #ifndef"
   },
   "item #if": {
      "prefix": ["if"],
      "body": [
         "#if ${1:0}",
         "$0",
         "#endif // ${1}"
      ],
      "description": "Code snippet for #if"
   },
   "item struct": {
      "prefix": ["struct"],
      "body": [
         "struct {",
         "   $0",
         "} ${1:var};"
      ],
      "description": "Code snippet for struct"
   },
   "item switch": {
      "prefix": ["switch", "case"],
      "body": [
         "switch (${1:switch_on}) {",
          "   default:",
          "      break;$2",
          "}"
      ],
      "description": "Code snippet for switch statement"
   },
   "item union": {
      "prefix": ["union"],
      "body": [
         "union ${1:MyUnion} {",
            "   $2",
            "};"
      ],
      "description": "Code snippet for union"
   },
   "item #inc": {
      "prefix": ["#inc"],
      "body": [
         "#include \"${1:stdio.h}\""
      ],
      "description": "Code snippet for #include"
   },
   "item #define": {
      "prefix": ["define"],
      "body": [
         "#define ${1:name} ${2:value} "
      ],
      "description": "Code snippet for #define"
   },
   "item aligned": {
      "prefix": ["aligned"],
      "body": [
         "__attribute((aligned(${1:16}))) ${2:char} ${3:var};"
      ],
      "description": "Code snippet for 'aligned' statement"
   },
   "item interrupt": {
      "prefix": ["interrupt"],
      "body": [
         "__attribute((interrupt)) void ${1:isr_routine}(void);"
      ],
      "description": "Code snippet for 'interrupt' statement"
   },
   "mrs": {
     "prefix": ["mrs"],
     "body": [
       "__asm volatile(\"mrs %0, ${1:reg}\" : \"=r\"(${2:var}));"
     ]
   },
   "msr": {
     "prefix": ["msr"],
     "body": [
       "__asm volatile(\"msr %0, ${1:reg}\" : : \"r\"(${2:var}));"
     ]
   },
   "asm": {
     "prefix": ["asm"],
     "body": [
       "__asm volatile(\"${1:assembly code}\");"
     ]
   },
   "easm": {
     "prefix": ["easm"],
     "body": [
       "__asm volatile(\"${1:assembly_code}\"",
       "      : ${2:\"=r\"(output_cvariable)}",
       "      : ${3:\"r\"(input_cvariable)}",
       "      : ${4:\"clobberlist\"});"
     ]
   },
   "barrier": {
     "prefix": ["barrier"],
     "body": [
       "// Compiler Barrier",
       "//   compiler nukes regsiter cache of memory",
       "//   gcc/armclang re-fetches into registers",
       "//   no assembly instructions are issued",
       "__asm__ volatile (\"\" ::: \"memory\");"
     ]
   },
   "synchronize": {
     "prefix": ["synchronize"],
     "body": [
       "// Tell the C compiler and the CPU to not move loads or stores",
       "// past this point, to ensure that all the stores in the critical",
       "// section are visible to other CPUs before the lock is released,",
       "// and that loads in the critical section occur strictly before",
       "// the lock is released.",
       "// On AArch64 this issues a \"dmb ish\" instruction",
       "__sync_synchronize();"
     ]
   },
   "release": {
     "prefix": ["release"],
     "body": [
       "// Release the lock, equivalent to lk->locked = 0.",
       "// This code doesn't use a C assignment, since the C standard",
       "// implies that an assignment might be implemented with",
       "// multiple store instructions.",
       "// On AArch64 this isues a Store Release Register operation",
       "// Releasing exclusive access held by preceeding LDAXR instruction",
       "// STLR 0 [lk->locked],",
       "__sync_lock_release(&memvar);"
     ]
   },
   "lock": {
     "prefix": ["lock"],
     "body": [
       "// On AArch64, sync_lock_test_and_set turns into an atomic swap:",
       "//   LDAXR Xt [&lk->locked]",
       "//   STLXR Ws Xt [&lk->locked], success when Ws=0",
       "// Implemented: Double loop to check for Ws=0 (inner) and ldaxr.Xt=0 (outer)",
       "localvar = __sync_swap(&memvar, 1);"
     ]
   }
}
